# Testing Your Code {#sec-testing}

## Introduction

"It works on my machine!" Sound familiar? Testing is how we ensure our code works correctly, not just today, but after every change we make. Whether you're building a small script or a large application, testing gives you confidence that your code does what it's supposed to do.

In this chapter, we'll explore testing in Python, learning how to write tests, use testing frameworks, and adopt test-driven development practices.

::: {.callout-note}
## What You'll Learn

- Why testing matters
- Writing tests with `unittest`
- Testing with `pytest`
- Test-driven development (TDD)
- Assertions and test organization
- Mocking and fixtures
- Best testing practices
:::

## Why Test?

Testing provides:
- **Confidence**: Know your code works
- **Documentation**: Tests show how code should be used
- **Safety**: Catch bugs before users do
- **Refactoring**: Change code without fear
- **Design**: Writing testable code leads to better design

::: {.callout-tip}
## The Testing Mindset

Good developers don't just write code that works now. They write code that continues to work as the project evolves. Testing is your safety net!
:::

## Types of Tests

```python
# Unit tests - Test individual functions/classes
def test_add():
    assert add(2, 3) == 5

# Integration tests - Test components together
def test_user_registration():
    user = create_user("alice@example.com")
    assert user_exists(user.email)

# Functional tests - Test entire features
def test_checkout_flow():
    add_to_cart(item)
    checkout()
    assert order_confirmed()
```

## Testing with `unittest`

`unittest` is Python's built-in testing framework.

### Basic Test Structure

```python
import unittest

def add(a, b):
    """Add two numbers"""
    return a + b

class TestMath(unittest.TestCase):
    def test_add_positive_numbers(self):
        """Test adding positive numbers"""
        self.assertEqual(add(2, 3), 5)

    def test_add_negative_numbers(self):
        """Test adding negative numbers"""
        self.assertEqual(add(-1, -1), -2)

    def test_add_zero(self):
        """Test adding zero"""
        self.assertEqual(add(5, 0), 5)

if __name__ == '__main__':
    unittest.main()
```

### Running Tests

```python
# Run from command line
# python test_math.py

# Run specific test
# python test_math.py TestMath.test_add_positive_numbers

# Run with verbosity
# python -m unittest test_math.TestMath -v
```

### Common Assertions

```python
import unittest

class TestAssertions(unittest.TestCase):
    def test_equality(self):
        self.assertEqual(1 + 1, 2)
        self.assertNotEqual(1 + 1, 3)

    def test_boolean(self):
        self.assertTrue(True)
        self.assertFalse(False)

    def test_none(self):
        value = None
        self.assertIsNone(value)
        self.assertIsNotNone(42)

    def test_membership(self):
        self.assertIn(3, [1, 2, 3])
        self.assertNotIn(4, [1, 2, 3])

    def test_type(self):
        self.assertIsInstance(42, int)
        self.assertIsInstance("hello", str)

    def test_comparison(self):
        self.assertGreater(5, 3)
        self.assertLess(3, 5)
        self.assertGreaterEqual(5, 5)
        self.assertLessEqual(3, 3)

    def test_almost_equal(self):
        # For floating point comparisons
        self.assertAlmostEqual(0.1 + 0.2, 0.3, places=7)

    def test_exceptions(self):
        with self.assertRaises(ValueError):
            int("not a number")

        with self.assertRaises(ZeroDivisionError):
            1 / 0
```

### Setup and Teardown

```python
import unittest

class TestWithSetup(unittest.TestCase):
    def setUp(self):
        """Run before each test"""
        self.data = [1, 2, 3, 4, 5]
        print("setUp called")

    def tearDown(self):
        """Run after each test"""
        self.data = None
        print("tearDown called")

    @classmethod
    def setUpClass(cls):
        """Run once before all tests in class"""
        print("setUpClass called")
        cls.shared_resource = "Shared"

    @classmethod
    def tearDownClass(cls):
        """Run once after all tests in class"""
        print("tearDownClass called")
        cls.shared_resource = None

    def test_first(self):
        self.assertEqual(len(self.data), 5)

    def test_second(self):
        self.assertIn(3, self.data)
```

### Testing Exceptions

```python
import unittest

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

class TestExceptions(unittest.TestCase):
    def test_divide_by_zero_raises_error(self):
        with self.assertRaises(ValueError):
            divide(10, 0)

    def test_divide_by_zero_message(self):
        with self.assertRaises(ValueError) as cm:
            divide(10, 0)
        self.assertEqual(str(cm.exception), "Cannot divide by zero")

    def test_normal_division(self):
        result = divide(10, 2)
        self.assertEqual(result, 5)
```

## Testing with `pytest`

`pytest` is a popular third-party testing framework that's simpler and more powerful than `unittest`.

### Installation

```bash
pip install pytest
```

### Basic pytest Tests

```python
# test_math.py
def add(a, b):
    return a + b

def test_add_positive():
    assert add(2, 3) == 5

def test_add_negative():
    assert add(-1, -1) == -2

def test_add_zero():
    assert add(5, 0) == 5
```

Running:
```bash
pytest test_math.py
pytest test_math.py::test_add_positive  # Run specific test
pytest -v  # Verbose output
pytest -s  # Show print statements
```

### pytest Assertions

```python
def test_assertions():
    # Simple assertions
    assert 1 + 1 == 2
    assert "hello" in "hello world"
    assert [1, 2, 3] == [1, 2, 3]

    # pytest provides detailed output on failure!
    x = 5
    assert x == 5, "x should be 5"

def test_exceptions():
    import pytest

    with pytest.raises(ValueError):
        int("not a number")

    with pytest.raises(ZeroDivisionError) as exc_info:
        1 / 0

    assert "division" in str(exc_info.value).lower()

def test_approximate():
    # For floating point
    assert 0.1 + 0.2 == pytest.approx(0.3)
    assert abs(0.1 + 0.2 - 0.3) < 1e-10
```

### Fixtures

Fixtures provide test data and setup:

```python
import pytest

@pytest.fixture
def sample_data():
    """Provide sample data for tests"""
    return [1, 2, 3, 4, 5]

def test_length(sample_data):
    assert len(sample_data) == 5

def test_sum(sample_data):
    assert sum(sample_data) == 15

@pytest.fixture
def database():
    """Setup and teardown database"""
    db = setup_database()
    yield db  # Test runs here
    teardown_database(db)

def test_query(database):
    result = database.query("SELECT * FROM users")
    assert len(result) > 0
```

### Parametrized Tests

Test multiple inputs efficiently:

```python
import pytest

def add(a, b):
    return a + b

@pytest.mark.parametrize("a, b, expected", [
    (2, 3, 5),
    (0, 0, 0),
    (-1, 1, 0),
    (10, -5, 5),
])
def test_add(a, b, expected):
    assert add(a, b) == expected

@pytest.mark.parametrize("text", [
    "racecar",
    "level",
    "radar",
])
def test_palindrome(text):
    assert text == text[::-1]
```

### Test Organization

```python
# tests/
#   __init__.py
#   test_math.py
#   test_string.py
#   conftest.py  # Shared fixtures

# conftest.py
import pytest

@pytest.fixture
def shared_data():
    return {"key": "value"}

# test_math.py
def test_using_shared_fixture(shared_data):
    assert "key" in shared_data
```

## Test-Driven Development (TDD)

TDD follows a simple cycle:
1. **Red**: Write a failing test
2. **Green**: Write minimal code to pass
3. **Refactor**: Improve code while keeping tests passing

### TDD Example

```python
# Step 1: Write test first (RED)
def test_calculate_average():
    numbers = [1, 2, 3, 4, 5]
    assert calculate_average(numbers) == 3.0

# This fails because calculate_average doesn't exist!

# Step 2: Write minimal code (GREEN)
def calculate_average(numbers):
    return sum(numbers) / len(numbers)

# Test passes!

# Step 3: Add more tests
def test_calculate_average_empty():
    assert calculate_average([]) == 0

# This fails! Update code:
def calculate_average(numbers):
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)

# Step 4: Refactor if needed
def calculate_average(numbers):
    """Calculate average of numbers, return 0 for empty list"""
    return sum(numbers) / len(numbers) if numbers else 0
```

## Testing Best Practices

### Write Clear Test Names

```python
# Bad: Unclear what's being tested
def test1():
    assert add(2, 3) == 5

# Good: Descriptive name
def test_add_returns_sum_of_two_positive_numbers():
    assert add(2, 3) == 5

# Good: Follows pattern
def test_add_with_negative_numbers_returns_correct_sum():
    assert add(-2, -3) == -5
```

### Test One Thing per Test

```python
# Bad: Testing multiple things
def test_user():
    user = create_user("alice@example.com")
    assert user.email == "alice@example.com"
    assert user.is_active
    assert user.created_at is not None

# Good: Separate tests
def test_user_email_is_set_correctly():
    user = create_user("alice@example.com")
    assert user.email == "alice@example.com"

def test_user_is_active_by_default():
    user = create_user("alice@example.com")
    assert user.is_active

def test_user_has_creation_timestamp():
    user = create_user("alice@example.com")
    assert user.created_at is not None
```

### Use Arrange-Act-Assert Pattern

```python
def test_user_registration():
    # Arrange - Setup test data
    email = "alice@example.com"
    password = "secure123"

    # Act - Perform the action
    user = register_user(email, password)

    # Assert - Verify the result
    assert user.email == email
    assert user.password != password  # Should be hashed
```

## Testing Real Functions

### Example: Testing a Calculator

```python
# calculator.py
class Calculator:
    def add(self, a, b):
        return a + b

    def subtract(self, a, b):
        return a - b

    def multiply(self, a, b):
        return a * b

    def divide(self, a, b):
        if b == 0:
            raise ValueError("Cannot divide by zero")
        return a / b

# test_calculator.py
import pytest
from calculator import Calculator

class TestCalculator:
    def setup_method(self):
        self.calc = Calculator()

    def test_add(self):
        assert self.calc.add(2, 3) == 5
        assert self.calc.add(-1, 1) == 0

    def test_subtract(self):
        assert self.calc.subtract(5, 3) == 2
        assert self.calc.subtract(0, 5) == -5

    def test_multiply(self):
        assert self.calc.multiply(3, 4) == 12
        assert self.calc.multiply(-2, 3) == -6

    def test_divide(self):
        assert self.calc.divide(10, 2) == 5
        assert self.calc.divide(7, 2) == 3.5

    def test_divide_by_zero_raises_error(self):
        with pytest.raises(ValueError, match="Cannot divide by zero"):
            self.calc.divide(10, 0)
```

### Example: Testing String Functions

```python
# string_utils.py
def reverse_string(text):
    """Reverse a string"""
    return text[::-1]

def is_palindrome(text):
    """Check if string is palindrome"""
    clean = text.lower().replace(" ", "")
    return clean == clean[::-1]

def count_vowels(text):
    """Count vowels in string"""
    return sum(1 for char in text.lower() if char in 'aeiou')

# test_string_utils.py
import pytest
from string_utils import reverse_string, is_palindrome, count_vowels

class TestStringUtils:
    def test_reverse_string(self):
        assert reverse_string("hello") == "olleh"
        assert reverse_string("") == ""
        assert reverse_string("a") == "a"

    def test_is_palindrome(self):
        assert is_palindrome("racecar")
        assert is_palindrome("A man a plan a canal Panama")
        assert not is_palindrome("hello")

    def test_count_vowels(self):
        assert count_vowels("hello") == 2
        assert count_vowels("aeiou") == 5
        assert count_vowels("xyz") == 0
        assert count_vowels("") == 0
```

### Example: Testing a Class

```python
# bank_account.py
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance

    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        self.balance += amount

    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        if amount > self.balance:
            raise ValueError("Insufficient funds")
        self.balance -= amount

    def get_balance(self):
        return self.balance

# test_bank_account.py
import pytest
from bank_account import BankAccount

class TestBankAccount:
    def test_initial_balance(self):
        account = BankAccount(100)
        assert account.get_balance() == 100

    def test_deposit_increases_balance(self):
        account = BankAccount(100)
        account.deposit(50)
        assert account.get_balance() == 150

    def test_withdraw_decreases_balance(self):
        account = BankAccount(100)
        account.withdraw(30)
        assert account.get_balance() == 70

    def test_deposit_negative_amount_raises_error(self):
        account = BankAccount(100)
        with pytest.raises(ValueError, match="must be positive"):
            account.deposit(-10)

    def test_withdraw_more_than_balance_raises_error(self):
        account = BankAccount(100)
        with pytest.raises(ValueError, match="Insufficient funds"):
            account.withdraw(150)

    def test_multiple_transactions(self):
        account = BankAccount(100)
        account.deposit(50)
        account.withdraw(30)
        account.deposit(20)
        assert account.get_balance() == 140
```

## Mocking

Mocking replaces real objects with test doubles:

```python
from unittest.mock import Mock, patch
import pytest

# Function that makes external API call
def get_user_data(user_id):
    # Imagine this makes a real API call
    import requests
    response = requests.get(f"https://api.example.com/users/{user_id}")
    return response.json()

# Test with mock
def test_get_user_data():
    with patch('requests.get') as mock_get:
        # Setup mock response
        mock_get.return_value.json.return_value = {
            'id': 1,
            'name': 'Alice'
        }

        result = get_user_data(1)

        assert result['name'] == 'Alice'
        mock_get.assert_called_once_with("https://api.example.com/users/1")
```

## Code Coverage

Measure how much code is tested:

```bash
# Install coverage
pip install pytest-cov

# Run tests with coverage
pytest --cov=mypackage tests/

# Generate HTML report
pytest --cov=mypackage --cov-report=html tests/
```

## Common Testing Patterns

### Testing Edge Cases

```python
def test_edge_cases():
    # Empty input
    assert my_function([]) == expected_empty_result

    # Single item
    assert my_function([1]) == expected_single_result

    # Large input
    assert my_function(range(1000)) == expected_large_result

    # Boundary values
    assert my_function(0) == expected_zero
    assert my_function(-1) == expected_negative
```

### Testing Error Handling

```python
def test_error_handling():
    with pytest.raises(TypeError):
        my_function("wrong type")

    with pytest.raises(ValueError):
        my_function(-1)

    with pytest.raises(IndexError):
        my_function(list_obj, 1000)
```

## Summary

In this chapter, we've explored:

- **Why testing matters** - Confidence, documentation, safety
- **unittest** - Python's built-in testing framework
- **pytest** - Modern, powerful testing framework
- **TDD** - Test-driven development methodology
- **Best practices** - Clear names, single responsibility, AAA pattern
- **Mocking** - Testing without external dependencies

Testing is essential for professional Python development. Make it a habit!

::: {.callout-tip}
## Key Takeaways

- Write tests for all critical functionality
- Test edge cases and error conditions
- Use descriptive test names
- Follow the Arrange-Act-Assert pattern
- Aim for high code coverage
- Use pytest for new projects
- Practice TDD for better code design
:::

## Practice Exercises

### Exercise 1: Test a Validator
Write tests for an email validator:

```python
def is_valid_email(email):
    # Your implementation
    pass

# Write comprehensive tests
```

### Exercise 2: Test a Shopping Cart
Create and test a shopping cart class:

```python
class ShoppingCart:
    def add_item(self, item, price):
        pass

    def remove_item(self, item):
        pass

    def get_total(self):
        pass

# Write tests for all methods
```

### Exercise 3: Test String Processing
Test a function that processes text:

```python
def process_text(text):
    # Removes punctuation, converts to lowercase
    pass

# Test various inputs including edge cases
```

### Exercise 4: Test with Parametrize
Use parametrize to test a temperature converter:

```python
def celsius_to_fahrenheit(celsius):
    pass

# Test multiple conversions in one test
```

### Exercise 5: Test Error Conditions
Write tests that verify proper error handling:

```python
def divide_numbers(a, b):
    pass

# Test that it raises appropriate errors
```

## Next Steps

In the next chapter, we'll explore **debugging** techniques and tools. Get ready to squash those bugs!
